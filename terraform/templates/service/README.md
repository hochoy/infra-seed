# SERVICE_NAME

Python microservice deployed on the infra-seed GKE cluster with automated CI/CD.

## ðŸ“‹ Table of Contents

- [Overview](#overview)
- [Getting Started](#getting-started)
- [Configuration](#configuration)
- [Local Development](#local-development)
- [Deployment](#deployment)
- [Accessing Your Service](#accessing-your-service)
- [Kubernetes Operations](#kubernetes-operations)
- [Troubleshooting](#troubleshooting)
- [Architecture](#architecture)

## Overview

This service is part of the infra-seed infrastructure with:
- **Automated deployments** via GitHub Actions
- **Namespace isolation** with RBAC controls
- **Workload Identity Federation** (no service account keys)
- **Automatic routing** through Gateway API

## Getting Started

### Prerequisites

- Access to the infra-seed GKE cluster (contact admin for RBAC permissions)
- `gcloud` CLI installed
- `kubectl` CLI installed
- Docker or Podman for local development

### Initial Setup

1. **Clone this repository**:
```bash
gh repo clone YOUR_ORG/SERVICE_NAME
cd SERVICE_NAME
```

2. **Authenticate with Google Cloud**:
```bash
gcloud auth login
```

3. **Get cluster credentials**:
```bash
# Get credentials (replace PROJECT_ID with actual project)
gcloud container clusters get-credentials infra-seed-cluster \
  --region=us-central1 \
  --project=PROJECT_ID

# Or use current project automatically
gcloud container clusters get-credentials infra-seed-cluster \
  --region=us-central1 \
  --project=$(gcloud config get-value project)
```

4. **Set your namespace context**:
```bash
kubectl config set-context --current --namespace=SERVICE_NAME
```

5. **Verify access**:
```bash
kubectl get pods
# You should see your service pods listed (or empty if not deployed yet)
```

## Configuration

### github.yaml

This file is auto-generated by Terraform and contains all necessary configuration:

```yaml
gcp:
  project_id: "your-project"           # GCP project ID
  region: "us-central1"                 # GCP region
  cluster_name: "infra-seed-cluster"       # GKE cluster name
  service_account: "deploy-xxx@..."     # GCP service account with WIF

registry:
  url: "us-central1-docker.pkg.dev/..." # Artifact Registry URL
  image_name: "SERVICE_NAME"             # Container image name

workload_identity:
  provider: "projects/xxx/..."          # WIF provider for GitHub Actions

kubernetes:
  namespace: "SERVICE_NAME"             # Your isolated namespace
  deployment_name: "SERVICE_NAME-deployment"
  service_name: "SERVICE_NAME-service"

app:
  port: 80                              # Application port
  replicas: 2                           # Number of pod replicas

build:
  context: "."                          # Docker build context
  dockerfile: "Dockerfile"              # Dockerfile location
```

## Local Development

### Python Environment Setup

#### Option 1: Using pyenv (Recommended for version isolation)

Isolate Python version to this repository:

```bash
# Install pyenv (if not already installed)
brew install pyenv
echo 'export PYENV_ROOT="$HOME/.pyenv"' >> ~/.zshrc
echo 'command -v pyenv >/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"' >> ~/.zshrc
echo 'eval "$(pyenv init -)"' >> ~/.zshrc

# Install and set Python version
pyenv install 3.11
pyenv local 3.11
```

#### Option 2: Using standard venv

```bash
# Create virtual environment
python3 -m venv .venv
source .venv/bin/activate  # Use 'deactivate' to exit
```

#### Option 3: Using devcontainers

Use devcontainers instead of managing Python versions locally. See [this guide](https://geekingoutpodcast.substack.com/p/running-dev-containers-locally-with).

### Install Dependencies and Run

```bash
# Install dependencies
pip install -r requirements.txt

# Run application
python src/app.py
# Or with auto-reload:
python -m uvicorn src.app:app --reload --port 80

# Test locally
curl http://localhost:80/
curl http://localhost:80/health

# Cleanup (if needed)
pip uninstall -r requirements.txt -y
```

### Container Runtime Setup

#### Using Docker

If you already have Docker installed, you're ready to go.

#### Using Podman (Alternative to Docker)

```bash
# Install Podman
brew install podman
brew install --cask podman-desktop
brew install podman-compose

# Initialize Podman machine
podman machine init --cpus=4 --memory=6144 --rootful=true my-podman
podman machine start my-podman
echo 'alias docker=podman' >> ~/.zshrc

# Cleanup (if needed)
podman machine list
podman machine stop my-podman
podman machine rm my-podman
```

### Build and Test Container Locally

```bash
# Build container (works with both docker and podman)
docker build -t SERVICE_NAME:test .

# Run container
docker run -d -p 8080:80 --name SERVICE_NAME-test SERVICE_NAME:test

# Test
curl http://localhost:8080/
curl http://localhost:8080/health

# View logs
docker logs SERVICE_NAME-test

# Cleanup
docker stop SERVICE_NAME-test
docker rm SERVICE_NAME-test
```

### Test with Minikube (Optional)

For testing full Kubernetes deployment locally:

```bash
# Start Minikube
minikube start

# Build image in Minikube
minikube image build -t SERVICE_NAME:test .

# Switch context
kubectl config use-context minikube

# Apply manifests
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml

# Port forward to test
kubectl port-forward svc/SERVICE_NAME-service 9000:80
curl http://localhost:9000/

# Switch back to GKE
kubectl config use-context gke_PROJECT_infra-seed-cluster_us-central1
```

## Deployment

### Automated Deployment (Recommended)

Deployment happens automatically via GitHub Actions when you push to `main`:

```bash
git add .
git commit -m "Your changes"
git push origin main
```

**What happens:**
1. GitHub Actions workflow triggers
2. Authenticates to GCP using Workload Identity Federation (no keys!)
3. Builds Docker image
4. Pushes to Artifact Registry
5. Updates Kubernetes deployment
6. Verifies pods are running

**Typical deployment time:** 3-5 minutes

### View Deployment Status

- **GitHub**: Check the "Actions" tab in this repository
- **Kubernetes**: 
  ```bash
  kubectl get pods -w  # Watch pods update
  kubectl rollout status deployment/SERVICE_NAME-deployment
  ```

### Rollback Deployment

If a deployment fails or has issues:

```bash
# Rollback to previous version
kubectl rollout undo deployment/SERVICE_NAME-deployment

# View rollout history
kubectl rollout history deployment/SERVICE_NAME-deployment

# Rollback to specific revision
kubectl rollout undo deployment/SERVICE_NAME-deployment --to-revision=2
```

## Accessing Your Service

### Service URL

Your service is accessible at:
```
https://YOUR_DOMAIN/SERVICE_PATH
```

Check `github.yaml` or the main infra-seed repository's `terraform/namespaces.tf` for your specific path.

### Test Endpoints

```bash
# Health check
curl https://YOUR_DOMAIN/SERVICE_PATH/health

# Service info
curl https://YOUR_DOMAIN/SERVICE_PATH/

# With authentication (if required)
curl -H "Authorization: Bearer TOKEN" https://YOUR_DOMAIN/SERVICE_PATH/endpoint
```

### Traffic Flow

```
User Request
    â†“
Cloudflare (DNS + DDoS protection)
    â†“
GCP Load Balancer + SSL
    â†“
Gateway API (path-based routing)
    â†“
Kubernetes Service (SERVICE_NAME-service)
    â†“
Your Pods
```

## Kubernetes Operations

### View Pods

```bash
# List pods
kubectl get pods

# Detailed pod info
kubectl describe pod POD_NAME

# Watch pods in real-time
kubectl get pods -w
```

### View Logs

```bash
# Recent logs from all pods
kubectl logs -l app=SERVICE_NAME --tail=50

# Follow logs in real-time
kubectl logs -l app=SERVICE_NAME -f

# Logs from specific pod
kubectl logs POD_NAME

# Previous container logs (if pod crashed)
kubectl logs POD_NAME --previous
```

### Debug Pods

```bash
# Execute into a pod
kubectl exec -it POD_NAME -- /bin/sh

# Run a command in pod
kubectl exec POD_NAME -- printenv

# Copy files from pod
kubectl cp POD_NAME:/path/to/file ./local-file
```

### View Service and Routing

```bash
# Service details
kubectl get service SERVICE_NAME-service
kubectl describe service SERVICE_NAME-service

# Check HTTPRoute (Gateway API routing)
kubectl get httproute -A | grep SERVICE_NAME

# View Gateway status
kubectl get gateway -n default
```

### Resource Usage

```bash
# Pod resource usage
kubectl top pods

# Node resource usage
kubectl top nodes
```

## Troubleshooting

### Deployment Fails

**Check GitHub Actions logs:**
1. Go to "Actions" tab in this repository
2. Click on the failed workflow run
3. Review build/deploy logs

**Common issues:**
- **Build fails**: Check Dockerfile and requirements.txt
- **Push fails**: Verify WIF configuration in `github.yaml`
- **Deploy fails**: Check deployment.yaml syntax

### Pods Not Starting

```bash
# Check pod status
kubectl get pods
kubectl describe pod POD_NAME

# Common issues:
# - ImagePullBackOff: Image doesn't exist or wrong registry
# - CrashLoopBackOff: Application crashes on startup
# - Pending: Resource constraints or node issues
```

### Application Errors

```bash
# View application logs
kubectl logs -l app=SERVICE_NAME --tail=100 -f

# Check if service is responding
kubectl exec POD_NAME -- curl localhost:80/health
```

### Cannot Access Service

1. **Check if pods are running:**
   ```bash
   kubectl get pods
   ```

2. **Check service endpoints:**
   ```bash
   kubectl get endpoints SERVICE_NAME-service
   ```

3. **Test from within cluster:**
   ```bash
   kubectl run -it --rm debug --image=curlimages/curl --restart=Never -- \
     curl http://SERVICE_NAME-service:80/health
   ```

4. **Check Gateway and HTTPRoute:**
   ```bash
   kubectl get httproute -A | grep SERVICE_NAME
   kubectl describe httproute SERVICE_NAME-route -n default
   ```

### Need Help?

- **Infrastructure Issues**: See main [infra-seed repository](https://github.com/YOUR_ORG/infra-seed)
- **Permission Issues**: Contact cluster administrator
- **Application Issues**: Check logs and review your code changes

## Architecture

### Namespace Isolation

Your service runs in an isolated namespace with:
- **Resource Quotas**: CPU, memory, and pod limits
- **Network Policies**: Default deny + allow same namespace
- **RBAC**: Namespace-scoped permissions

### Roles and Permissions

- **Administrators**: Full access to namespace resources (read, write, delete)
- **Viewers**: Read-only access to namespace resources

Check the main infra-seed repository's `terraform/namespaces.tf` to see who has access.

### CI/CD Pipeline

```
Push to main
    â†“
GitHub Actions Triggered
    â†“
Authenticate via WIF (no keys!)
    â†“
Build Docker Image
    â†“
Push to Artifact Registry
    â†“
Update Kubernetes Deployment
    â†“
Rolling Update (zero downtime)
```

### Related Documentation

- [Main infra-seed Repository](https://github.com/YOUR_ORG/infra-seed) - Infrastructure documentation
- [GKE Documentation](https://cloud.google.com/kubernetes-engine/docs)
- [Gateway API](https://gateway-api.sigs.k8s.io/)

## API Endpoints

Customize this section based on your service:

- `GET /` - Service information
- `GET /health` - Health check endpoint
- `GET /your-endpoint` - Your custom endpoints

### Example Response

```json
{
  "service": "SERVICE_NAME",
  "version": "1.0.0",
  "endpoints": [
    "GET /",
    "GET /health"
  ]
}
```
